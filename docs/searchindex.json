{"categories":[{"title":"binary","uri":"http://algorithms.gluecoders.com/categories/binary/"},{"title":"bit","uri":"http://algorithms.gluecoders.com/categories/bit/"}],"posts":[{"content":"Introduction Since binary consists of only 1s and 0s, most operations can be done by flipping bits through XOR(^) operation. Applying XOR on two bits yields 1 only if both the bits are different.\nSwapping bits at given positions To swap bits at given positions, we will first see whether the bits are even different. If the bits are different then we can just XOR with a bitmask to flip them essentially swapping the bits as a result.\npublic static long swapBits(long num, int i, int j) { if (((num \u0026gt;\u0026gt; i) \u0026amp; 1) != ((num \u0026gt;\u0026gt; j) \u0026amp; 1)) { long bitMask = (1 \u0026lt;\u0026lt; i) | (1 \u0026lt;\u0026lt; j); num ^= bitMask; } return num; }  This technique can also be used to reverse the bits of a given number.\nprivate static void reverseBits(long num) { int j = (int) (Math.log(num) / Math.log(2)); for (int i = 0; i \u0026lt; (j+1)/2; i++) { num = swapBits(num, i, j - i); } }  Finding position of rightmost bit set / least significant bit set First we apply AND operation on num and (num-1). Since the least significant bit is different, applying AND will unset the least significant bit from num.\nAfterwards XORing the AND result with original num will cancel all the 1s except for the rightmost one since that was not set in AND result.\npublic static long lowestSetBitNumber(long num) { return num ^ (num \u0026amp; (num - 1)); }  ","id":0,"section":"posts","summary":"Introduction Since binary consists of only 1s and 0s, most operations can be done by flipping bits through XOR(^) operation. Applying XOR on two bits yields 1 only if both the bits are different.\nSwapping bits at given positions To swap bits at given positions, we will first see whether the bits are even different. If the bits are different then we can just XOR with a bitmask to flip them essentially swapping the bits as a result.","tags":null,"title":"Bit Hacks","uri":"http://algorithms.gluecoders.com/2020/01/bithacks/","year":"2020"},{"content":"Introduction Parity is 1 if the number of set bits are odd else it is 0.\nCalculating number of set bits by AND // \u0026quot;AND\u0026quot; between num and num-1 will always remove rightmost set bit(bit which is 1) public static int parityByAndWithLesserNumber(long num) { int total = 0; while (num != 0) { total++; num = num \u0026amp; (num - 1); } return total \u0026amp; 1 ; }  Caching for lower order numbers private static int parityByCache(int x, int[] cache, int numberBitSize) { int cacheUnit = numberBitSize / 4; int bitMask = (1 \u0026lt;\u0026lt; cacheUnit) - 1; int parity = 0; parity ^= cache[x \u0026amp; bitMask]; parity ^= cache[(x \u0026gt;\u0026gt; cacheUnit) \u0026amp; bitMask]; parity ^= cache[(x \u0026gt;\u0026gt; 2 * cacheUnit) \u0026amp; bitMask]; parity ^= cache[(x \u0026gt;\u0026gt; 3 * cacheUnit) \u0026amp; bitMask]; return parity; } private static int[] buildParityCache(int numberBitSize) { int[] cache = new int[(1 \u0026lt;\u0026lt; numberBitSize / 4)]; IntStream.range(0, (1 \u0026lt;\u0026lt; (numberBitSize/4)) - 1) .forEach(x -\u0026gt; cache[x] = Integer.bitCount(x) \u0026amp; 1); return cache; }  ","id":1,"section":"posts","summary":"Introduction Parity is 1 if the number of set bits are odd else it is 0.\nCalculating number of set bits by AND // \u0026quot;AND\u0026quot; between num and num-1 will always remove rightmost set bit(bit which is 1) public static int parityByAndWithLesserNumber(long num) { int total = 0; while (num != 0) { total++; num = num \u0026amp; (num - 1); } return total \u0026amp; 1 ; }  Caching for lower order numbers private static int parityByCache(int x, int[] cache, int numberBitSize) { int cacheUnit = numberBitSize / 4; int bitMask = (1 \u0026lt;\u0026lt; cacheUnit) - 1; int parity = 0; parity ^= cache[x \u0026amp; bitMask]; parity ^= cache[(x \u0026gt;\u0026gt; cacheUnit) \u0026amp; bitMask]; parity ^= cache[(x \u0026gt;\u0026gt; 2 * cacheUnit) \u0026amp; bitMask]; parity ^= cache[(x \u0026gt;\u0026gt; 3 * cacheUnit) \u0026amp; bitMask]; return parity; } private static int[] buildParityCache(int numberBitSize) { int[] cache = new int[(1 \u0026lt;\u0026lt; numberBitSize / 4)]; IntStream.","tags":null,"title":"Parity of a number","uri":"http://algorithms.gluecoders.com/2020/01/parityofnumber/","year":"2020"}],"tags":[]}